---
title: "Selection analyses on the bladder"
output: html_document
---

##Selection on known cancer genes

To study selection at known cancer genes, we can combine the coding mutations of all urothelium samples subject to targeted or whole-exome data. To avoid counting multiple times those mutations present in clones spanning multiple biopsies, we can conservatively use unique mutations per donor. We will analyse samples from transplant donors first, and then run a combined analysis of transplant donors and apparent-normal urothelium from bladder cancer patients (cystectomy samples).

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.path='Figs/', dev=c('png','pdf'), warning=FALSE, message=FALSE)
```

Merging the WES and TGS mutation calls.

We load the mutations, calculate allele counts and VAFs, and merge the exome (Caveman and Pindel) and targeted (Shearwater) calls.

```{r message=FALSE, warning=FALSE}
setwd("/Users/im3/Desktop/Bladder/Analyses_July2019")
caveman_file = "bld_exome_caveman_calls.tsv"
pindel_file = "bld_exome_pindel_calls.tsv"
targeted_file = "bld_targeted_shearwater_calls.tsv"
patient_file = "bladder_patient_info_2019-10-30.csv"
lcm_file = "2019-10-01_LCM_database.rds"
targeted_coverage_file = "bld_targeted_picard_coverage.tsv"
targetgenes = c(read.table("normal_baits_genes.txt", header=0, sep="\t", stringsAsFactors=F)[,1], "CDKN2A.p14arf", "CDKN2A.p16INK4a") # Adding the two CDKN2A isoforms
patientdata = read.table(patient_file, header=1, sep=",", stringsAsFactors=F)
gender = setNames(patientdata$gender, patientdata$internal_id)

# Loading exome+targeted mutations
muts.exome.cave = read.table(caveman_file, header=1, sep="\t", stringsAsFactors=F)
muts.exome.pind = read.table(pindel_file, header=1, sep="\t", stringsAsFactors=F)
muts.tgs = read.table(targeted_file, header=1, sep="\t", stringsAsFactors=F)[,1:8] # Including VAFs

# Calculating VAFs for the Caveman calls
counts = as.matrix(muts.exome.cave[,c("gt_FAZ","gt_FCZ","gt_FGZ","gt_FTZ")]) + as.matrix(muts.exome.cave[,c("gt_RAZ","gt_RCZ","gt_RGZ","gt_RTZ")])
muts.exome.cave$mut_dep = NA
muts.exome.cave$all_dep = rowSums(counts)
nts = c(A=1,C=2,G=3,T=4)
for (j in 1:nrow(muts.exome.cave)){ muts.exome.cave$mut_dep[j] = counts[j,nts[muts.exome.cave$ALT[j]]] }
muts.exome.cave$vaf = muts.exome.cave$mut_dep / muts.exome.cave$all_dep

# Annotating dinucleotides (and runs of subs of any length) in Caveman
muts.exome.cave = muts.exome.cave[order(muts.exome.cave$sampleID, muts.exome.cave$CHROM, muts.exome.cave$POS), ]
d = muts.exome.cave$POS-(1:nrow(muts.exome.cave))
runs = rle(d)
rmpos = rep(0,nrow(muts.exome.cave))
runstarts = cumsum(runs$length)-runs$length+1
for (h in 1:length(runs$length)) {
    if (runs$length[h]>1) { # Adjacent mutations
        mutcluster = runstarts[h]:(runstarts[h]+runs$lengths[h]-1)
        rmpos[mutcluster[-1]] = 1 # Removing all the affected rows except the first one (which we will edit to capture the complex event)
        muts.exome.cave[mutcluster[1],"REF"] = paste(muts.exome.cave[mutcluster,"REF"],collapse="")
        muts.exome.cave[mutcluster[1],"ALT"] = paste(muts.exome.cave[mutcluster,"ALT"],collapse="")
    }
}
muts.exome.cave = muts.exome.cave[!rmpos,]

# Deletions in Pindel are annotated to the base upstream of the deleted base, unlike Shearwater. I change this to the Shearwater annotation to combine both later.
dels = nchar(muts.exome.pind$REF)>nchar(muts.exome.pind$ALT)
#dels = muts.exome.pind$PC=="D"
muts.exome.pind$POS[dels] = muts.exome.pind$POS[dels] + 1
muts.exome.pind$REF[dels] = substr(muts.exome.pind$REF[dels],2,nchar(muts.exome.pind$REF[dels]))
muts.exome.pind$ALT[dels & nchar(muts.exome.pind$ALT)==1] = "-"
muts.exome.pind$ALT[dels & nchar(muts.exome.pind$ALT)>1] = substr(muts.exome.pind$ALT[dels & nchar(muts.exome.pind$ALT)>1],2,nchar(muts.exome.pind$ALT[dels & nchar(muts.exome.pind$ALT)>1]))
muts.exome.pind$ALT[!dels] = "INS" # Annotating insertions like Shearwater

# Merging exome and targeted data
muts.exome.cave = muts.exome.cave[,c("sampleID","CHROM","POS","REF","ALT","mut_dep","all_dep","vaf")]
muts.exome.pind$mut_dep = muts.exome.pind$gt_MTR
muts.exome.pind$all_dep = muts.exome.pind$gt_MTR + muts.exome.pind$gt_WTR
muts.exome.pind$vaf = muts.exome.pind$mut_dep / muts.exome.pind$all_dep
muts.exome.pind = muts.exome.pind[,c("sampleID","CHROM","POS","REF","ALT","mut_dep","all_dep","vaf")]
muts.exome = rbind(muts.exome.cave, muts.exome.pind)
colnames(muts.exome) = colnames(muts.tgs)
write.table(muts.exome, file="bld_exome_caveman_and_pindel_calls.tsv", sep="\t", quote=F, col.names=T, row.names=T)
muts.all = unique(rbind(muts.tgs,muts.exome))
muts.all = muts.all[order(muts.all$sampleID, muts.all$chr, muts.all$pos), ]

# When the same mutation was detected by TGS and WXS, I retain the record with the highest coverage (I do not combine the counts as they could contain PCR duplicates)
mstr = paste(muts.all$sampleID,muts.all$chr,muts.all$pos,muts.all$mut,sep=":")
rmrows = rep(0,nrow(muts.all))
for (j in 2:nrow(muts.all)) {
    if (mstr[j]==mstr[j-1]) { # Same mutation
        rmrows[j-(muts.all$all_dep[j]>muts.all$all_dep[j-1])] = 1
    }
}
muts.all = muts.all[!rmrows, ]

# Evaluating groups of adjacent mutations.
# Indels close to one another will be collapsed as they most often represent double-counted (TGS + WES) or complex events.
# Substitutions very close to indels will be removed as they typically represent mapping artefacts at the end of reads.
dist_cluster = 10
indl = !(muts.all$ref %in% c("A","C","G","T")) | !(muts.all$mut %in% c("A","C","G","T"))
aux = muts.all$sampleID[1:(nrow(muts.all)-1)]==muts.all$sampleID[2:nrow(muts.all)] &
    muts.all$chr[1:(nrow(muts.all)-1)]==muts.all$chr[2:nrow(muts.all)] &
    (muts.all$pos[1:(nrow(muts.all)-1)]+dist_cluster) >= muts.all$pos[2:nrow(muts.all)]

clusters = rle(aux)
clust_end = cumsum(clusters$lengths)[clusters$values==T] + 1
clust_start = clust_end - clusters$lengths[clusters$values==T]
rmrows = rep(0,nrow(muts.all))
for (j in 1:length(clust_start)) { # For each cluster we chose 1 mutations based on 2 rules: (1) Indel take precedence over substitutions, (2) Higher VAF.
    ind = clust_start[j]:clust_end[j]
    if (any(indl[ind])) {
        chosen = which.max(muts.all$vaf[ind] + !(muts.all$mut[ind] %in% c("A","C","G","T")))
        rmrows[ind[-chosen]] = 1
    }
}
muts.all = muts.all[!rmrows, ]

write.table(muts.all, file="bld_exometgs_subsindels_combined.tsv", sep="\t", col.names=T, row.names=F, quote=F)
```

Driver discovery.

```{r message=FALSE, warning=FALSE}
targeted_coverage_file = "bld_targeted_picard_coverage.tsv"
tcgablca_file = "mc3.v0.2.8.PUBLIC.uniqueperdonor.BLCA.6cols.txt" # Public MC3 calls for 411 muscle-invasive bladder cancers
targetgenes = c(read.table("normal_baits_genes.txt", header=0, sep="\t", stringsAsFactors=F)[,1], "CDKN2A.p14arf", "CDKN2A.p16INK4a") # Adding the two CDKN2A isoforms
bladder_cancer_genes_Martincorena = c("TP53","PIK3CA","ARID1A","RB1","CDKN2A","KMT2D","KDM6A","STAG2","ZFP36L1","ELF3","CDKN1A","FGFR3","TSC1","EP300","RHOB","FBXW7","CREBBP","RHOA","ERCC2","PTEN","KMT2C","HRAS","SPTAN1","PSIP1","FOXA1","FOXQ1","FAT1","RXRA","ERBB2","KMT2A","RBM10","KLF5","ARID2","KRAS","NFE2L2","ERBB3","EPS8","KANSL1","HIST1H3B","C3orf70","ASXL2","CDKN2A.p14arf","CDKN2A.p16INK4a") # Martincorena et al, Cell, 2017
bladder_cancer_genes_TCGA = c("TP53","PIK3CA","RB1","RHOB","KDM6A","TSC1","ELF3","KMT2D","CREBBP","CDKN1A","EP300","ZFP36L1","ARID1A","STAG2","CDKN2A","HRAS","KRAS","FBXW7","ERCC2","ASXL2","RHOA","KMT2A","FGFR3","NFE2L2","KMT2C","KANSL1","PSIP1","C3orf70","FAT1","SPTAN1","RXRA","ZBTB7B","PTEN","ATM","KLF5","PARD3","CUL1","NRAS","SF3B1","GNA13","RBM10","ACTB","MBD1","CASP8","HIST1H3B","TAF11","ERBB2","NUP93","SF1","ERBB3","METTL3","SPN","MB21D2","SSH3","USP28","ASXL1","TMCO4","HES1","CDKN2A.p14arf","CDKN2A.p16INK4a")
bladder_cancer_genes = unique(c(bladder_cancer_genes_Martincorena,bladder_cancer_genes_TCGA))

# Selecting urothelial samples
patientdata = read.table(patient_file, header=1, sep=",", stringsAsFactors=F)
lcmdata = readRDS(lcm_file)
urot_ids = as.vector(lcmdata$SupplierSampleName[lcmdata$Feature=="Urothelium" & as.vector(lcmdata$Donor) %in% patientdata$external_id[patientdata$patient_type=="transplant"]])
#urot_ids = as.vector(lcmdata$SupplierSampleName[lcmdata$Feature=="Urothelium"]) # Including cystectomies
mutations = muts.all[which(muts.all$sampleID %in% urot_ids),]
mutations$sampleID = substr(mutations$sampleID,1,7) # Using patient identifiers instead of sample identifiers
mutations = unique(mutations) # Unique mutations per patient
```

###Gene-level analysis: dNdScv

We then run dNdScv on all genes in the bait capture. We do so as in the oesophagus paper, excluding genes significant from dNdSloc (based on substitutions alone) from the indel background model of dNdScv.

```{r message=FALSE, warning=FALSE}
library(dndscv)
library(knitr)
dndsout = dndscv(mutations, gene_list=targetgenes, max_muts_per_gene_per_sample=Inf, max_coding_muts_per_sample=Inf, outmats=T)
dndsloc_genes = as.vector(dndsout$sel_loc$gene_name[dndsout$sel_loc$qall_loc<0.05])
dndsout = dndscv(mutations, gene_list=targetgenes, max_muts_per_gene_per_sample=Inf, max_coding_muts_per_sample=Inf, outmats=T, kc=dndsloc_genes)
dndsout$sel_cv$qrht = NA
dndsout$sel_cv$qrht[dndsout$sel_cv$gene_name %in% bladder_cancer_genes] = p.adjust(dndsout$sel_cv$pglobal_cv[dndsout$sel_cv$gene_name %in% bladder_cancer_genes], method="BH")
# Significant genes
sel_cv = dndsout$sel_cv[which(dndsout$sel_cv$qmis_cv<0.05 | dndsout$sel_cv$qglobal_cv<0.05 | dndsout$sel_cv$qrht<0.10), c(1:8,10,15:17,19,20)]
sel_cv$signif = sel_cv$qglobal_cv<0.01 | sel_cv$qmis_cv<0.01
sel_cv$known = sel_cv$gene_name %in% bladder_cancer_genes
dndsout_ref = dndsout # We save the main dndsout output object for use in a later section
kable(sel_cv, caption="Output of dNdScv", row.names=F)
```

Evaluating the results using different cutoffs, running dNdScv with and without cystectomy samples and using dNdSloc or prior bladder cancer genes to exclude genes from the indel model, reveals that there are a set of 10 genes which dNdScv finds as clearly significant (qglobal<<0.01). They are all known bladder cancer genes except NOTCH2. Two additional genes show clear significance for missense mutations (qmis_cv<0.01), CREBBP and ERCC2, and should be included. Restricted hypothesis testing on known bladder cancer genes also yields KLF5 (qrht=0.0072). KLF5 could be mentioned in the main text based on the RHT support. With qrht<0.10 we also find support for: PTEN, ZFP36L1 and ELF3. Overall, there are 12 genes that can be considered as clearly significant by dNdScv (qglobal_cv<0.01 or qmis_cv<0.01) (KDM6A, KMT2D, ARID1A, CDKN1A, RBM10, STAG2, RHOA, EP300, FOXQ1, NOTCH2, CREBBP, ERCC2), and 4 additional bladder cancer genes with support from RHT (KLF5, PTEN, ZFP36L1 and ELF3).

```{r message=FALSE, warning=FALSE}
drivers = as.vector(sel_cv$gene_name[which(sel_cv$qmis_cv<0.01 | sel_cv$qglobal_cv<0.01 | sel_cv$qrht<0.1)])
print(drivers)
```

Relaxing the cutoffs slightly (qglobal<0.05 or qmis<0.05) reveals 7 additional genes: FOXQ1, EEF1A1, KLF5, FOSL2, CARD11, AMER1, SPOP. Only FOXQ1 and KLF5 are in the list of bladder cancer genes and are already found by RHT. SPOP is an interesting case as it has 4 missense mutations, all at or near known hotspots. SPOP is discussed later in this document. The support for the remaining genes is less clear but I suggest mentioning them, at least in the Supplementary Material.

We can also use the output of dNdScv to evaluate the global dN/dS ratios from the targeted genes.

```{r message=FALSE, warning=FALSE}
global.dnds = dndsout$globaldnds
print(global.dnds)
```

These global dN/dS ratios are slightly lower than those from the oesophagus, but higher than those in the eyelids. Although caution should be exercised in making these comparisons as they depend on the background mutation rate (much higher in sun-exposed skin) and can be affected by the detection sensitivity and the sizes of the clones detected. Global dN/dS ratios on the targeted genes can be used to estimate the % of nonsynonymous mutations in the targeted genes that are drivers and the estimated number of driver mutations in the targeted and exome data (restricted to the targeted genes). 

```{r fig_global_dNdS, fig.height = 4, fig.width = 5}
par(mfrow=c(1,3))
# Global dN/dS values in the targeted genes
w = as.matrix(global.dnds[c(1,4),-1]) # wmis and wtrunc values
b = barplot(w[,1], names.arg=c("mis","tru"), col=c("chocolate","cadetblue"), ylim=c(0,max(w)), las=1, ylab="Global dN/dS (targeted genes)")
segments(x0=b, y0=w[,2], y1=w[,3])
abline(h=1, lty=2)
# Driver fractions
f = (w-1)/w
b = barplot(f[,1], names.arg=c("mis","tru"), col=c("chocolate","cadetblue"), ylim=c(0,1), las=1, ylab="Fraction drivers (targeted genes)")
segments(x0=b, y0=f[,2], y1=f[,3])
# Number of drivers
n = f*c(sum(dndsout$genemuts$n_mis), sum(dndsout$genemuts$n_non+dndsout$genemuts$n_spl))
b = barplot(n[,1], names.arg=c("mis","tru"), col=c("chocolate","cadetblue"), ylim=c(0,max(n)), las=1, ylab="Number drivers (targeted genes)")
segments(x0=b, y0=n[,2], y1=n[,3])
print(colSums(n)) # Estimated number of drivers
```

In the oesophagus paper, we obtained a conservative estimate of the number of driver mutations focusing only on genes under significant positive selection. This made possible the inclusion of indels, using non-significant genes in the targeted panel as putative passengers. Applying this approach to the bladder data yields an estimate of the number of substitution drivers in the 17 driver genes of 235 (CI95%:210,250) (code below, subs only -ndriv_subs-), as expected lower than the number estimated above considering all 322 targeted genes: 344 (CI95%:262,411) (code above). Although the confidence intervals are wide, this suggests that there are driver mutations to be discovered in the targeted gene list outside of the 17 significant genes.

Note that conservatively using non-significant genes as approximately neutral background still yields a very high enrichment of indels in the 17 significant genes (wind): obs/exp = 23.5 (CI95%:18.6,29.8). In total, 156 indels were observed in the 17 significant genes, of which ~149.4 are predicted to be drivers (ndriv_inds). Summing substitutions and indels yields an estimated number of driver mutations in the 16 significant genes of: 381.6 (CI95%:354,398).

```{r message=FALSE, warning=FALSE}
drivers = unique(c(drivers,"GNA13")) # Adding GNA13 from sitednds/codondnds
nmuts = as.matrix(dndsout$sel_cv[,2:6])
rownames(nmuts) = dndsout$sel_cv$gene_name
nmuts = nmuts[drivers,]
wmat = as.matrix(dndsout$sel_cv[,7:10])
rownames(wmat) = dndsout$sel_cv$gene_name
wmat = wmat[drivers,]
# Substitutions: simply running dndscv (global dN/dS) for the 17 driver genes
dnds2 = dndscv(mutations, gene_list=drivers, max_muts_per_gene_per_sample = Inf, max_coding_muts_per_sample = Inf, outp=1)
w = as.matrix(dnds2$globaldnds[5,-1])
n = sum(as.vector(table(dnds2$annotmuts$impact)[c("Missense","Nonsense","Essential_Splice")]))
ndriv_subs = (w-1)/w*n # This yields 
# Indels: we can use the confidence interval of the ratio of two Poissons
data("refcds_hg19", package="dndscv")
RefCDS = RefCDS[sapply(RefCDS, function(x) x$gene_name) %in% targetgenes]
genelengths = sapply(RefCDS, function(x) x$CDS_length)
genes = sapply(RefCDS, function(x) x$gene_name)
nind = table(dndsout$annotmuts[dndsout$annotmuts$mut %in% c("-","INS"),"gene"])[targetgenes]
nind[is.na(nind)] = 0
lvec = c(sum(genelengths[genes %in% dndsloc_genes]), sum(genelengths[!(genes %in% dndsloc_genes)]))
nvec = c(sum(nind[dndsloc_genes]),sum(nind[!(names(nind) %in% dndsloc_genes)]))
indpois = poisson.test(x=nvec, T=lvec)
wind = c(indpois$estimate, indpois$conf.int) # Global obs/exp ratio for indels in the 13 genes using all other genes as the background (conservative estimates)
ndriv_inds = (wind-1)/wind*nvec[1]
print(ndriv_subs+ndriv_inds) # Conservative calculation of the number of driver mutations with conservative CI95%
```

###Hotspot-level analysis: sitednds and codondnds

We can then use the new sitednds and codondnds functions to evaluate whether there is evidence of selection at site or codon level. There are two main ways of running these methods, on all sites of the target genes or using restricted hypothesis testing on a priori cancer hotspots. We first run sitednds. Both analysing all sites or using RHT, sitednds yields no significant hits (qvals>0.05). This is the case whether we use the NB (Negative Binomial) or LNP (Lognormal-Poisson) models. However, the observed/expected ratio of mutations in known hotspots is high, providing statistical support for most mutations overlapping known hotspots or hotcodons (10 and 14 respectively) being genuine drivers.

```{r message=FALSE, warning=FALSE}
data("knownhotspots_hg19", package="dndscv") # Previously known hotspots
known_hotspots = known_hotspots[sapply(known_hotspots, function(x) strsplit(x, split=":")[[1]][5]) %in% targetgenes] # Known hotspots in targetgenes
hotspots_geneRHT = sitednds(dndsout, gene_list = targetgenes, method = "LNP")
hotspots_siteRHT = sitednds(dndsout, site_list = known_hotspots, min_recurr = 1, method = "LNP")
kable(hotspots_geneRHT$recursites[hotspots_geneRHT$recursites$qval<0.01,], caption="Output of sitednds (all sites)", row.names=F)
kable(hotspots_siteRHT$recursites[hotspots_siteRHT$recursites$qval<0.01,], caption="Output of sitednds (RHT on cancer hotspots)", row.names=F)
```

Similarly, we can use codondnds to run this analysis at codon level.

```{r message=FALSE, warning=FALSE}
data("knownhotcodons_hg19", package="dndscv") # Previously known hotcodons
data("refcds_hg19", package="dndscv") # Load RefCDS
RefCDS = RefCDS[sapply(RefCDS, function(x) x$gene_name) %in% targetgenes]
RefCDSnew = buildcodon(RefCDS) # Adding codon information to RefCDS
hotcodons_geneRHT = codondnds(dndsout, RefCDSnew, gene_list = targetgenes, method = "LNP")
hotcodons_codonRHT = codondnds(dndsout, RefCDSnew, codon_list = known_hotcodons, min_recurr = 1, method = "LNP")
kable(hotcodons_geneRHT$recurcodons[hotcodons_geneRHT$recurcodons$qval<0.01,], caption="Output of codondnds (all codons)", row.names=F)
kable(hotcodons_codonRHT$recurcodons[hotcodons_codonRHT$recurcodons$qval<0.01,], caption="Output of codondnds (RHT on cancer hotcodons)", row.names=F)
```

Analysing all codons in the targeted genes yields GNA13:R200 and RHOA:F106 as significantly recurrent codons, with 3 mutations each and qval=0.001. The codon-RHT finds ERCC2 codon N238 as significant, with two mutations. 

Overall, the sitednds and codondnds analyses support GNA13 as a new bladder cancer hit. GNA13 is a little-known bladder cancer gene with a dominant hotspot at R200. In the bladder cancer TCGA calls (Caveman) there are 10 missense mutations in GNA13, of which 6 hit the R200 aminoacid (from a total of 390 tumours), confirming that GNA13 is also recurrently mutated in bladder cancer. GNA13 was not found by dNdScv in Martincorena et al., 2017, but was reported by TCGA in their bladder cancer paper (Robertson et al., 2017; PMID:28988769). **This takes the list of statistically-supported drivers that we may want to highlight in the main text to 17**. The RHT approach on sites or codons does not seem to yield anything new and we can choose not to report it.

```{r message=FALSE, warning=FALSE}
drivers = c(drivers, "GNA13")
```

Unfortunately, SPOP does not reach significance in any of these analyses, even though it was close to significance based on qmis_cv when using dNdScv (qmis_cv=0.035). SPOP contains 4 missense mutations and they all occur at (or near) known hotspots. Despite their obvious clustering, none of them are recurrent and so escape detection with sitednds or codondnds. Interestingly, there is evidence of these hotspots in the TCGA bladder cancer dataset, with 3 instances of SPOP:R130. 

```{r message=FALSE, warning=FALSE}
kable(dndsout$annotmuts[dndsout$annotmuts$gene=="SPOP",])
```

##Analyses including normal urothelium from the cystectomy samples

We can repeat the main analyses above including apparently normal urothelial samples from the five cystectomy patients.

```{r message=FALSE, warning=FALSE}
# Preparing the table of mutations
urot_ids = as.vector(lcmdata$SupplierSampleName[lcmdata$Feature=="Urothelium"])
#urot_ids = as.vector(lcmdata$SupplierSampleName[lcmdata$Feature=="Urothelium" & as.vector(lcmdata$Donor) %in% patientdata$external_id[patientdata$patient_type!="transplant"]]) # Cystectomies alone
mutations = muts.all[which(muts.all$sampleID %in% urot_ids),]
mutations$sampleID = substr(mutations$sampleID,1,7) # Using patient identifiers instead of sample identifiers
mutations = unique(mutations) # Unique mutations per patient
# Gene-wise dN/dS
dndsout = dndscv(mutations, gene_list=targetgenes, max_muts_per_gene_per_sample=Inf, max_coding_muts_per_sample=Inf, outmats=T, kc=dndsloc_genes)
dndsout$sel_cv$qrht = NA
dndsout$sel_cv$qrht[dndsout$sel_cv$gene_name %in% bladder_cancer_genes] = p.adjust(dndsout$sel_cv$pglobal_cv[dndsout$sel_cv$gene_name %in% bladder_cancer_genes], method="BH")
sel_cv = dndsout$sel_cv[which(dndsout$sel_cv$qmis_cv<0.05 | dndsout$sel_cv$qglobal_cv<0.05 | dndsout$sel_cv$qrht<0.10), c(1:8,10,15:17,19,20)]
sel_cv$signif = sel_cv$qglobal_cv<0.01 | sel_cv$qmis_cv<0.01 | sel_cv$qrht<0.10
sel_cv$known = sel_cv$gene_name %in% bladder_cancer_genes
write.table(sel_cv, file="Table_SXX_driver_discovery_transplant_donors_and_cystectomies.txt", col.names=T, row.names=F, sep="\t", quote=F)
kable(sel_cv, caption="Output of dNdScv", row.names=F)
```

At gene level, the addition of the cystectomy samples adds **EEF1A1** to the list of significant genes using qglobal<0.01. Overall, the results are quite similar including or excluding the cystectomy samples. The main difference is some strengthening of the statistical support for EEF1A1 and SPOP (1 extra missense mutations). We could show these results in the Suppl Material if desired.

```{r message=FALSE, warning=FALSE}
# Site-dN/dS
hotspots_geneRHT = sitednds(dndsout, gene_list = targetgenes, method = "LNP")
hotspots_siteRHT = sitednds(dndsout, site_list = known_hotspots, min_recurr = 1, method = "LNP")
kable(hotspots_geneRHT$recursites[hotspots_geneRHT$recursites$qval<0.01,], caption="Output of sitednds (all sites)", row.names=F)
kable(hotspots_siteRHT$recursites[hotspots_siteRHT$recursites$qval<0.01,], caption="Output of sitednds (RHT on cancer hotspots)", row.names=F)
# Codon-dN/dS
hotcodons_geneRHT = codondnds(dndsout, RefCDSnew, gene_list = targetgenes, method = "LNP")
hotcodons_codonRHT = codondnds(dndsout, RefCDSnew, codon_list = known_hotcodons, min_recurr = 1, method = "LNP")
kable(hotcodons_geneRHT$recurcodons[hotcodons_geneRHT$recurcodons$qval<0.01,], caption="Output of codondnds (all codons)", row.names=F)
kable(hotcodons_codonRHT$recurcodons[hotcodons_codonRHT$recurcodons$qval<0.01,], caption="Output of codondnds (RHT on cancer hotcodons)", row.names=F)
```

Sitednds only finds RHOA E172K with qval<0.01 in the analysis of all sites, and RHOA E47K in the RHT of known cancer hotspots. Codondnds finds RHOA F106. This is an interesting observation since the most frequently mutated codon in COSMIC in RHOA is G17, often seen in certain lymphomas. However, E47K, and to a lesser extent, E172K and F106, are minor hotspots in COSMIC and are most prevalent in bladder cancers according to COSMIC.

###Analyses of von Brunn's nests

The analyses above did not include mutations detected in von Brunn's nests. We can run a similar analysis to look for driver mutations in them.

```{r message=FALSE, warning=FALSE}
# Preparing the table of mutations
urot_ids = as.vector(lcmdata$SupplierSampleName[lcmdata$Feature %in% c("von Brunn's nest")])
mutations = muts.all[which(muts.all$sampleID %in% urot_ids),]
mutations$sampleID = substr(mutations$sampleID,1,7) # Using patient identifiers instead of sample identifiers
#mutations = unique(mutations) # Unique mutations per patient
# Gene-wise dN/dS
dndsout = dndscv(mutations, gene_list=targetgenes, max_muts_per_gene_per_sample=Inf, max_coding_muts_per_sample=Inf, outmats=T, kc=dndsloc_genes)
dndsout$sel_cv$qrht = NA
dndsout$sel_cv$qrht[dndsout$sel_cv$gene_name %in% bladder_cancer_genes] = p.adjust(dndsout$sel_cv$pglobal_cv[dndsout$sel_cv$gene_name %in% bladder_cancer_genes], method="BH")
sel_cv = dndsout$sel_cv[which(dndsout$sel_cv$qmis_cv<0.05 | dndsout$sel_cv$qglobal_cv<0.05 | dndsout$sel_cv$qrht<0.05), c(1:8,10,15:17,19,20)]
sel_cv$signif = sel_cv$qglobal_cv<0.01 | sel_cv$qmis_cv<0.01 | sel_cv$qrht<0.10
sel_cv$known = sel_cv$gene_name %in% bladder_cancer_genes

kable(sel_cv, caption="Output of dNdScv", row.names=F)
kable(dndsout$annotmuts[dndsout$annotmuts$gene %in% drivers,], caption="Coding mutations in 13 driver genes in von Brunn's nests")
```

There are only 91 unique coding mutations detected in the gene panel in von Brunn's nests, according to the annotation above. Despite the very low number of mutations, dNdScv finds some evidence of selection in ARID1A (qglobal=0.039), which has 2 indels, 1 nonsense and 1 essential splice site mutations. Beyond this, there is little evidence of selection in von Brunn's nests, although the numbers of mutations are too low to say much. We can use global dN/dS ratios to get an idea of the level of enrichment of non-synonymous mutations in the 321 targeted genes.

```{r}
print(dndsout$globaldnds)
```

Global dN/dS ratios in the 321 targeted genes appear low and, in fact, do not show definitive evidence of selection (although they are slightly higher than 1). They may even appear lower than those in normal urothelium, however the confidence intervals are overlapping to those from normal urothelium. In fact, if we repeat the calculation of global dN/dS ratios for the normal urothelium samples from the 3 patients from which von Brunn's nests were cut (PD40845, PD38779, PD40844) (analysis not shown here), the dN/dS values are not detectably different: wmis = 1.57 (CI95%:0.75,3.24) and wtru = 3.07 (CI95%:1.10,8.52), and the only gene found as significant is also ARID1A (again with 2 indels and 2 truncating substitutions). There are also two mutations in common in ARID1A in von Brunn's nests and in normal urothelium from the same patients, suggesting a certain level of sharing of mutations. **Are these samples adjacent? (ARID1A chr1:27100093 and chr1:27106804).** [To be followed up]

###Squamoid samples

There may be too few squamoid samples to study them separately with dNdScv. Nothing appears special from a quick look, and in fact there is only one mutation in the list of 17 driver genes (a missense mutation in KLF5).

```{r message=FALSE, warning=FALSE}
# Preparing the table of mutations
urot_ids = as.vector(lcmdata$SupplierSampleName[lcmdata$Feature %in% c("Squamoid")])
mutations = muts.all[which(muts.all$sampleID %in% urot_ids),]
mutations$sampleID = substr(mutations$sampleID,1,7) # Using patient identifiers instead of sample identifiers
mutations = unique(mutations) # Unique mutations per patient
# Gene-wise dN/dS
dndsout = dndscv(mutations, gene_list=targetgenes, max_muts_per_gene_per_sample=Inf, max_coding_muts_per_sample=Inf, outmats=T, kc=dndsloc_genes) # Nothing near significance
# Coding mutations in the 321 targeted genes
kable(dndsout$annotmuts, caption="Coding mutations in the targeted genes")
```

##Selection analyses on the entire exome: drivers, global dN/dS, global dN/dS on passenger genes (confirming near-neutral accumulation of passengers)

The availability of 655 whole-exomes (653 with at least 1 mutation) offers a rare opportunity to look into positive and negative selection on non-cancer genes.

```{r message=FALSE, warning=FALSE}
#urot_ids = as.vector(lcmdata$SupplierSampleName[lcmdata$Feature %in% c("Urothelium","von Brunn's nest")])
urot_ids = as.vector(lcmdata$SupplierSampleName[lcmdata$Feature=="Urothelium" & as.vector(lcmdata$Donor) %in% patientdata$external_id[patientdata$patient_type=="transplant"]])
mutations = muts.exome[which(muts.exome$sampleID %in% urot_ids),]
mutations$sampleID = substr(mutations$sampleID,1,7)
mutations = unique(mutations)
dndsout = dndscv(mutations, outmats=T) # We could exclude all known bladder cancer genes from the indel background model for simplicity
sel_cv = dndsout$sel_cv[which(dndsout$sel_cv$qmis_cv<0.05 | dndsout$sel_cv$qglobal_cv<0.05), c(1:8,10,15:17,19)] # When run with indels
sel_cv$signif = sel_cv$qglobal_cv<0.01 | sel_cv$qmis_cv<0.01 # When run with indels
data("cancergenes_cgc81", package="dndscv")
sel_cv$known = sel_cv$gene_name %in% c(bladder_cancer_genes, known_cancergenes)
dndsout_exome = dndsout # We save the main dndsout output object for use in a later section
kable(sel_cv, caption="Output of dNdScv", row.names=F)
```

Two genes that are not known cancer genes appear as significant in the exome data: PTRHD1 and KRTAP5-3. PTRHD1 is supported by three identical nonsense mutations in three different patients. This is likely to be a recurrent artefact, but this needs to be followed up by a Shearwater validation of these mutations [TO BE DONE -Federico has code and could help do this analysis-]. Similarly, KRTAP5-3 is likely to be an artefact. [Federico has kindly accepted to explore these potential artefacts using SNP databases and/or shearwater on the mutant sites].

We can also exclude driver genes to study global dN/dS in passengers. The analysis below shows a slight upward bias of global dN/dS, particularly for missense mutations, although this could be at least partially due to the normal pannel filtering and APOBEC mutagenesis. All in all, there is no evidence of negative selection acting in these samples, although our power is limited to detect this beyond a global analysis.

```{r}
urot_ids = as.vector(lcmdata$SupplierSampleName[lcmdata$Feature=="Urothelium" & as.vector(lcmdata$Donor) %in% patientdata$external_id[patientdata$patient_type=="transplant"]])
mutations = muts.exome[which(muts.exome$sampleID %in% urot_ids),]
mutations$sampleID = substr(mutations$sampleID,1,7)
mutations = unique(mutations)

pass = read.table("putative_passengers_from_multiple_sources_20170606.txt", header=0, sep="\t", stringsAsFactors=F)[,1]
dndsout_pass = dndscv(mutations, gene_list=pass) # We could exclude all known bladder cancer genes from the indel background model for simplicity
print(dndsout_pass$globaldnds)

dndsout_driv = dndscv(mutations, gene_list=targetgenes, outp=1) # We could exclude all known bladder cancer genes from the indel background model for simplicity
print(dndsout_driv$globaldnds)

dndsglob = rbind(dndsout_driv$globaldnds[1:3,-1], rep(NA,3), dndsout_pass$globaldnds[1:3,-1])
#dev.new(height=3, width=4)
bh = barplot(dndsglob[,1], names.arg=c("Missense","Nonsense","Splice","","Missense","Nonsense","Splice"), 
             ylim=c(0, max(dndsglob, na.rm=T)), las=2, ylab="Global dN/dS ratios", 
             col=c("cadetblue","darkorchid4","darkorchid2","white","cadetblue","darkorchid4","darkorchid2"), border=NA)
segments(x0=bh, y0=dndsglob[,2], y1=dndsglob[,3])
abline(h=1, lty=2)
#dev.copy(pdf, file="Fig2_global_dnds.pdf", width=4, height=3); dev.off(); dev.off()
```


##Driver barplot

One way to summarise some of the main driver results could be the representation used in the skin and oesophagus papers. The figure below shows the list of positively-selected genes, the number of mutations per gene, the dN/dS ratios, the percentage of mutant epithelium (lower bound estimate) and the frequency of these mutations in bladder cancers from TCGA. This plot will be complemented with a scatter plot of the frequency of mutations in normal bladder and TCGA bladder cancers, and a heatmap of the distribution of drivers across patients.

###Driver analysis of TCGA BLCA data

We can use the MC3 public calls, available for 411 bladder cancers. All these samples are from muscle-invasive tumours (confirmed using the TCGA barcodes from the TCGA 2017 paper in Cell). This yields 42 significant genes with the cutoffs used for the normal bladder (without RHT).

```{r message=FALSE, warning=FALSE}
mutations = read.table(tcgablca_file, header=1, sep="\t", stringsAsFactors=F)[,1:5]
dndsout = dndscv(mutations, outp=2) # Running only dNdSloc
dndsloc_genes_tcga = as.vector(dndsout$sel_loc$gene_name[dndsout$sel_loc$qall_loc<0.05])
dndsout_blca = dndscv(mutations, outmats=T, kc=dndsloc_genes_tcga)
sel_cv = dndsout_blca$sel_cv[which(dndsout_blca$sel_cv$qmis_cv<0.05 | dndsout_blca$sel_cv$qglobal_cv<0.05), c(1:8,10,15:17,19)]
sel_cv$signif = sel_cv$qglobal_cv<0.01 | sel_cv$qmis_cv<0.01
data("cancergenes_cgc81", package="dndscv")
sel_cv$known = sel_cv$gene_name %in% c(bladder_cancer_genes, known_cancergenes)
kable(sel_cv, caption="Output of dNdScv", row.names=F)
```

For comparison with the targeted data from the normal bladder, we can use RHT on the 321 targeted genes. This is better than running dndscv using "gene_list = targetgenes" as it uses the whole-exome data to fit the background model. This yields a list of 48 significant genes in bladder cancer that overlap with the targeted gene list. The code below also calculates the % of patients with a non-synonymous mutation in each of the significant genes.

```{r message=FALSE, warning=FALSE}
sel_cv = dndsout_blca$sel_cv[dndsout_blca$sel_cv$gene_name %in% targetgenes, ]
sel_cv$qglobal_cv = p.adjust(sel_cv$pglobal_cv, method="BH")
sel_cv$qmis_cv = p.adjust(sel_cv$pmis_cv, method="BH")
sel_cv = sel_cv[which(sel_cv$qglobal_cv<0.01 | sel_cv$qmis_cv<0.01), c(1:8,10,15:17,19)]
sel_cv$patientfreq = sapply(sel_cv$gene_name, function(x) length(unique(dndsout_blca$annotmuts$sampleID[dndsout_blca$annotmuts$gene==x & dndsout_blca$annotmuts$impact!="Synonymous"])) / length(unique(mutations$sampleID)) )
sel_cv_blca = sel_cv
kable(sel_cv, caption="Output of dNdScv", row.names=F)
```

```{r fig_driver_barplot, fig.height = 7, fig.width = 4}
drivers = c("KDM6A","KMT2D","ARID1A","CDKN1A","RBM10","STAG2","RHOA","EP300","FOXQ1","NOTCH2","CREBBP","ERCC2","KLF5","PTEN","ZFP36L1","ELF3","GNA13")
genes2plot = drivers[order(rowSums(as.matrix(dndsout_ref$sel_cv[dndsout_ref$sel_cv$gene_name %in% drivers, 3:6])), drivers, decreasing=T)] # Significant genes sorted by frequency
genes2plot = c(genes2plot, c("TP53","PIK3CA","RB1","FGFR3")) # TP53, PIK3CA and RB1 are the other most mutated genes in BLCA. FGFR3 is a top 5, but even more frequent in non-muscle invasive tumours

#dev.new(height=8, width=4)
par(mfrow=c(4,1), mar=c(3,5.5,2,2))

# a. Mutations observed
nmuts = as.matrix(dndsout_ref$sel_cv[,2:6])
rownames(nmuts) = dndsout_ref$sel_cv$gene_name
nmuts = nmuts[genes2plot,]
subs_per_gene = t(nmuts)
rownames(subs_per_gene) = c("Synonymous","Missense","Nonsense","Splice","Indels")
colvec = c("grey70","cadetblue","darkorchid4","darkorchid2","chocolate3")
pos = barplot(subs_per_gene, las=2, col=colvec, border=NA, ylim=c(0, max(colSums(subs_per_gene))+5), ylab="Total mutations")
legend("topright",y=max(apply(subs_per_gene,2,sum))*1.09,legend=rownames(subs_per_gene),fill=colvec,border=NA,box.col=NA)
verticalbar = mean(pos[(0:1)+length(drivers)])
abline(v=verticalbar)

# b. % of TCGA BLCA tumours with a mutation
blca = read.table(tcgablca_file, header=1, sep="\t", stringsAsFactors=F)
numsamples = length(unique(blca[,1])) # Number of BLCA samples
ns = unique(dndsout_blca$annotmuts[dndsout_blca$annotmuts$impact!="Synonymous", c("sampleID","gene")])
freqs = (table(ns[,2])/numsamples)[genes2plot] * 100 # % of patients with one or more non-synonymous mutation
freqs[is.na(freqs)] = 0; names(freqs) = genes2plot
colvec = c("darkorange","grey40") # For significant vs non-significant genes in TCGA
pos = barplot(freqs, border=NA, las=2, ylim=c(0,50), ylab="% bladder tumours", col=colvec[(names(freqs) %in% bladder_cancer_genes)+1])
legend(x=8, y=54, legend=c("Known bladder cancer driver","Not known"),fill=c("grey40","darkorange"),border=NA,box.col=NA)
k = cbind(freqs*length(unique(blca[,1]))/100, length(unique(blca[,1])))
ci = apply(k, 1, function(x) binom.test(x=x[1],n=x[2])$conf.int) * 100
segments(x0=pos, y0=ci[1,], y1=ci[2,], col="grey20")
abline(v=verticalbar)
blca_freqs = freqs
blca_ci = ci

# c. dN/dS ratios from the dNdScv model
obsw = as.matrix(dndsout_ref$sel_cv[,c(7,8,10)])
rownames(obsw) = dndsout_ref$sel_cv$gene_name
colnames(obsw) = c("Missense","Nonsense+splice","Indels")
obsw = obsw[genes2plot,]
#obsp = as.matrix(dndsout_ref$sel_cv[,c(11,12,14)]); rownames(obsp) = dndsout_ref$sel_cv$gene_name; obsp = obsp[genes2plot,]; obsw[obsp>0.05] = NA # Masking out P>0.05
pos = barplot(t(obsw), beside=T, las=2, col=c("cadetblue","darkorchid3","chocolate3"), border=NA, ylim=c(0,max(obsw,na.rm=T)+10), ylab="dN/dS ratios")
legend("topright",y=max(apply(obsw,2,sum))*1.09,legend=colnames(obsw),fill=c("cadetblue","darkorchid3","chocolate3"),border=NA,box.col=NA)
abline(h=1, col="grey")
abline(v=mean(pos[(0:1)+length(drivers)*3]))

# d. % of mutant urothelium (we will use targeted sequenced samples with median coverage >=50 from transplant donors >=50 years)

min_coverage = 50 # Only considering samples with this minimum coverage
min_age = 50 # Only donors with this minimum age
coverage_table1 = read.table(targeted_coverage_file, header=1, sep="\t", stringsAsFactors=F)
coverage_table2 = read.table("bld_exome_picard_coverage.tsv", header=1, sep="\t", stringsAsFactors=F)
enough_cov = unique(c(coverage_table1$SAMPLE_ID[which(coverage_table1$MEDIAN_TARGET_COVERAGE>=min_coverage)],
               coverage_table2$SAMPLE_ID[which(coverage_table2$MEDIAN_TARGET_COVERAGE>=min_coverage)]))

urot_ids = intersect(enough_cov, as.vector(lcmdata$SupplierSampleName[lcmdata$Feature=="Urothelium" & as.vector(lcmdata$Donor) %in% patientdata$external_id[patientdata$patient_type=="transplant"]]))
urot_ids = urot_ids[substr(urot_ids,1,7) %in% patientdata$internal_id[patientdata$age>=min_age]]
num_samples = sum((lcmdata$SentForTargeted=="Y" | lcmdata$SentForExome=="Y") & lcmdata$SupplierSampleName %in% urot_ids)

mutations = dndscv(muts.all[which(muts.all$sampleID %in% urot_ids),1:5], gene_list=targetgenes, max_muts_per_gene_per_sample=Inf, max_coding_muts_per_sample=Inf, outp=1)$annotmuts # Annotating the mutations
mutations$str = paste(mutations$sampleID, mutations$chr, mutations$pos, mutations$mut, sep=":")
vafs = setNames(muts.all$vaf, paste(muts.all$sampleID, muts.all$chr, muts.all$pos, muts.all$mut, sep=":"))
mutations$vaf = vafs[mutations$str]

# Correction for X-chr genes
xchr_genes = unique(dndsout_ref$annotmuts$gene[dndsout_ref$annotmuts$gene %in% genes2plot & dndsout_ref$annotmuts$chr=="X"])
male_patients = patientdata$internal_id[patientdata$gender=="Male"]

# Initialising analysis per gene
fraction_mutant_cells = array(0,dim=c(2,length(genes2plot)))
colnames(fraction_mutant_cells) = genes2plot
rownames(fraction_mutant_cells) = c("highbd","lowbd")
ns = mutations[which(mutations$impact!="Synonymous" & mutations$gene %in% genes2plot),] # Table with all non-synonymous mutations

# Initialising analysis per sample per gene (for the calculation of totals across genes)
fraction_mutant_cells_persample_low = array(0, dim=c(num_samples,length(genes2plot)))
s = unique(mutations$sampleID)
rownames(fraction_mutant_cells_persample_low) = c(s, rep("",num_samples-length(s)))
colnames(fraction_mutant_cells_persample_low) = genes2plot
fraction_mutant_cells_persample_high = fraction_mutant_cells_persample_low

for (j in 1:length(genes2plot)) {
    nsj = ns[ns$gene==genes2plot[j],]
    nspersample = split(nsj, f=nsj$sampleID)
    if (nrow(nsj)==0) {
        fraction_mutant_cells[,j] = 0
    } else {
        if (!(genes2plot[j] %in% xchr_genes)) { # Genes in autosomes
            
            aux = sapply(nspersample, function(x) c(min(1,sum(x$vaf*2)), min(1,sum(x$vaf))))
            fraction_mutant_cells[,j] = rowSums(aux) / num_samples
            fraction_mutant_cells_persample_low[colnames(aux), genes2plot[j]] = aux[2,]
            fraction_mutant_cells_persample_high[colnames(aux), genes2plot[j]] = aux[1,]
            
        } else { # Genes in X-chr (different calculation for male and female patients)
            f = array(0,dim=c(length(nspersample),2)) # Initialise
            rownames(f) = names(nspersample)
            for (p in 1:length(nspersample)) {
                if (substr(nspersample[[p]]$sampleID[1],1,7) %in% male_patients) { # Male
                    f[p,] = min(1,sum(nspersample[[p]]$vaf))
                } else { # Female (standard diploid case)
                    f[p,] = c(min(1,sum(nspersample[[p]]$vaf*2)), min(1,sum(nspersample[[p]]$vaf)))
                }
            }
            fraction_mutant_cells[,j] = colSums(f) / num_samples
            fraction_mutant_cells_persample_low[rownames(f), genes2plot[j]] = f[,2]
            fraction_mutant_cells_persample_high[rownames(f), genes2plot[j]] = f[,1]
        }
    }
}
aux = rbind(fraction_mutant_cells[2,],fraction_mutant_cells[1,]-fraction_mutant_cells[2,]) * 100
pos = barplot(aux, las=2, col=c("white","indianred3"), border=NA, ylab="% mutant epithelium", ylim=c(0,6))
abline(v=verticalbar)
#dev.copy(pdf, file="Driver_barplot.pdf", width=4, height=7); dev.off(); dev.off()
```

In the main text, we also have a statement about the total fraction of cells carrying a driver mutation, aggregated across all driver genes. There are different ways of obtaining this estimate. The most general way is providing a lower bound (assuming that driver mutations in the same biopsy are clonally nested) and a higher bound (assuming that driver mutations in different genes affect different cells of a biopsy). The code below provides this estimate:

```{r}
mean(apply(fraction_mutant_cells_persample_low, 1, function(x) max(x))) # Lower bound estimate
mean(apply(fraction_mutant_cells_persample_high, 1, function(x) min(1,sum(x)))) # Higher bound estimate
}

```



##Variation in the driver landscape across patients (comparison of dN/dS ratios across patients)

A remarkable feature of the bladder data is the extent of variation in the driver landscape across patients. Formally testing differences in selection per gene across patients is not straightforward. Differences in the frequency of driver mutations in a gene can be due to differences in mutation rates or mutation detection sensitivity (e.g. due to coverage, biopsy sizes, etc). dN/dS ratios can help control for some of these differences, but a gene can show significantly different dN/dS ratios in two patients simply due to large differences in mutation rates and so overall dN/dS ratios in a patient (e.g. higher mutation rates, such as those caused by exposure to mutagens or acquired hypermutation, can lead to lower dN/dS ratios). 

One method to identify outlier patients with a particular enrichment of driver mutations in a given gene was to compare dN/dS ratios per gene between two datasets (i.e. one patient vs the rest), while correcting for overall dN/dS differences in a set of cancer genes. The function below does this.

###Variation in selection of single genes in specific patients

```{r}
# Function. Comparing dN/dS values between two datasets using the uniform model and removing global differences in dN/dS between two datasets
variable_dNdS_twodatasets = function(dnds1, dnds2, genestotest) {
    
    library("dndscv")
    pvec = rmisvec = rtruvec = rep(NA, length(genestotest)) # Initialising vectors for p-values and for the ratios of wmis and wtru between dataset 1 and 2
    w1 = dnds1$globaldnds$mle; names(w1) = dnds1$globaldnds$name
    w2 = dnds2$globaldnds$mle; names(w2) = dnds2$globaldnds$name
    
    for (g in 1:length(genestotest)) {
        
        # We can implement a simple LRT model based on the uniform dNdS model
        # This is different from the Fisher test in that it uses synonymous mutations (i.e. dN/dS ratios)
        # instead of comparing the contribution of nonsyn muts of a gene *relative* to other genes.
        # Being a uniform model it assumes no considerable changes in the mutation rate variation or coverage
        # across genes in both datasets. But takes into account signature and rate variation between two
        # datasets.
        # H0: wmis1==wmis2 & wtru1==wtru2
        # H1: wmis1!=wmis2 & wtru1!=wtru2
        # This is simply done using obs1, exp1, obs2, exp2 (y1 and y2 vectors below)
        
        y1 = as.numeric(dnds1$genemuts[dnds1$genemuts$gene==genestotest[g],])
        y2 = as.numeric(dnds2$genemuts[dnds2$genemuts$gene==genestotest[g],])
        
        # Global dN/dS ratios from all other genes (to normalise the differences for the gene being tested)        
        ind1 = dnds1$genemuts$gene!=genestotest[g]
        ind2 = dnds2$genemuts$gene!=genestotest[g]
        wmis1_global = sum(dnds1$genemuts$n_mis[ind1])/sum(dnds1$genemuts$exp_mis[ind1])
        wmis2_global = sum(dnds2$genemuts$n_mis[ind2])/sum(dnds2$genemuts$exp_mis[ind2])
        wtru1_global = sum(dnds1$genemuts$n_non[ind1]+dnds1$genemuts$n_spl[ind1])/sum(dnds1$genemuts$exp_non[ind1]+dnds1$genemuts$exp_spl[ind1])
        wtru2_global = sum(dnds2$genemuts$n_non[ind2]+dnds2$genemuts$n_spl[ind2])/sum(dnds2$genemuts$exp_non[ind2]+dnds2$genemuts$exp_spl[ind2])
        
        # MLE dN/dS ratios using the uniform model under H0 and H1
        wmis_mle0 = (y1[3]+y2[3])/(y1[7]*wmis1_global+y2[7]*wmis2_global)
        wtru_mle0 = sum(y1[4:5]+y2[4:5])/sum(y1[8:9]*wtru1_global+y2[8:9]*wtru2_global)
        wmis_mle1 = c(y1[3],y2[3])/c(y1[7]*wmis1_global,y2[7]*wmis2_global)
        wtru_mle1 = c(sum(y1[4:5]),sum(y2[4:5]))/c(sum(y1[8:9]*wtru1_global),sum(y2[8:9]*wtru2_global))
        
        # Observed and predicted counts under H0 and H1
        obs = as.numeric(c(y1[3], sum(y1[4:5]), y2[3], sum(y2[4:5])))
        exp0 = as.numeric(c(y1[7]*wmis1_global*wmis_mle0, sum(y1[8:9])*wtru1_global*wtru_mle0, y2[7]*wmis2_global*wmis_mle0, sum(y2[8:9])*wtru2_global*wtru_mle0))
        exp1 = as.numeric(c(y1[7]*wmis1_global*wmis_mle1[1], sum(y1[8:9])*wtru1_global*wtru_mle1[1], y2[7]*wmis2_global*wmis_mle1[2], sum(y2[8:9])*wtru2_global*wtru_mle1[2])) # Note that exp1 == obs (we only have this line here for confirmation purposes)
        ll0 = c(sum(dpois(x=obs[c(1,3)], lambda=exp0[c(1,3)], log=T)), sum(dpois(x=obs[c(2,4)], lambda=exp0[c(2,4)], log=T)))
        ll1 = c(sum(dpois(x=obs[c(1,3)], lambda=exp1[c(1,3)], log=T)), sum(dpois(x=obs[c(2,4)], lambda=exp1[c(2,4)], log=T)))
        
        # One-sided p-values
        pvals = (1-pchisq(2*(ll1-ll0), df=1))
        if (wmis_mle1[1]<wmis_mle1[2]) { pvals[1] = 1 } else { pvals[1] = pvals[1]/2 }
        if (wtru_mle1[1]<wtru_mle1[2]) { pvals[2] = 1 } else { pvals[2] = pvals[2]/2 }
        
        # Saving the results
        pvec[g] = 1 - pchisq(-2 * sum(log(pvals)), df = 4) # Fisher combined p-value
        rmisvec[g] = wmis_mle1[1]/wmis_mle1[2]
        rtruvec[g] = wtru_mle1[1]/wtru_mle1[2]
        
    }
    out = data.frame(genestotest,pvec,rmisvec,rtruvec)
    return(out)
}
```

Using the "variable_dNdS_twodatasets" function, we can compare the dN/dS ratios per gene (relative to the global dN/dS ratio in driver genes) comparing each patient vs all others.

```{r message=FALSE, warning=FALSE}
urot_ids = as.vector(lcmdata$SupplierSampleName[lcmdata$Feature=="Urothelium" & as.vector(lcmdata$Donor) %in% patientdata$external_id[patientdata$patient_type=="transplant"]])
mutations = muts.all[which(muts.all$sampleID %in% urot_ids),]
mutations$sampleID = substr(mutations$sampleID,1,7) # Using patient identifiers instead of sample identifiers
mutations = unique(mutations) # Unique mutations per patient
pats = unique(mutations$sampleID) # Donor list

nummuts = sort(table(dndsout_ref$annotmuts$gene[dndsout_ref$annotmuts$impact!="Synonymous" & dndsout_ref$annotmuts$gene %in% drivers]), decreasing = T)
drivers2test = names(nummuts[nummuts>=10]) # Testing only genes with at least 10 non-synonymous mutations in total

pmat_enrich = pmat_deplet = pmat_fisher = rmis = rtru = array(NA, dim=c(length(drivers2test),length(pats)), dimnames=list(drivers2test,pats)) # Initialised arrays
n_ns1 = n_ns2 = array(NA, dim=c(length(drivers),length(pats)), dimnames=list(drivers,pats)) # Initialised arrays

for (j in 1:length(pats)) {
    dnds1 = dndscv(mutations[mutations$sampleID==pats[j],], gene_list=targetgenes, max_muts_per_gene_per_sample = Inf, max_coding_muts_per_sample = Inf)
    dnds2 = dndscv(mutations[mutations$sampleID!=pats[j],], gene_list=targetgenes, max_muts_per_gene_per_sample = Inf, max_coding_muts_per_sample = Inf)
    out = variable_dNdS_twodatasets(dnds1, dnds2, genestotest=drivers2test)
    rmis[,j] = out$rmisvec
    rtru[,j] = out$rtruvec
    #out2 = variable_dNdS_twodatasets(dnds2, dnds1, genestotest=drivers2test)
    pmat_enrich[,j] = out$pvec
    #pmat_deplet[,j] = out2$pvec
    n1 = setNames(rowSums(as.matrix(dnds1$sel_cv[,colnames(dnds1$sel_cv) %in% c("n_mis","n_non","n_spl","n_ind")])), dnds1$sel_cv$gene_name) # Including indels
    n2 = setNames(rowSums(as.matrix(dnds2$sel_cv[,colnames(dnds2$sel_cv) %in% c("n_mis","n_non","n_spl","n_ind")])), dnds2$sel_cv$gene_name) # Including indels
    #n1 = (dnds1$genemuts$n_mis+dnds1$genemuts$n_non+dnds1$genemuts$n_spl); names(n1) = dnds1$genemuts$gene # Not including indels
    #n2 = (dnds2$genemuts$n_mis+dnds2$genemuts$n_non+dnds2$genemuts$n_spl); names(n2) = dnds2$genemuts$gene # Not including indels
    n_ns1[,j] = n1[drivers]
    n_ns2[,j] = n2[drivers]
    #pmat_fisher[,j] = sapply(1:nrow(n_ns1), function(x) fisher.test(x=array(c(n_ns1[x,j],sum(n_ns1[-x,j]),n_ns2[x,j],sum(n_ns2[-x,j])), dim=c(2,2)))$p.value)
}

qmat_enrich = array(p.adjust(pmat_enrich, method="BH"), dim=dim(pmat_enrich), dimnames=dimnames(pmat_enrich))
ind = which(qmat_enrich<0.05, arr.ind=T)
signif = data.frame(donor=rownames(qmat_enrich)[ind[,1]], gene=colnames(qmat_enrich)[ind[,2]], qval=qmat_enrich[ind], test="Enriched")
signif = signif[order(signif$qval),]
print(signif, row.names=F)
```

The analysis above identifies a number of interesting outliers, offering some formal demonstration that the driver landscape varies across individuals, while correcting for inter-individual differences in mutation burden, mutation detection sensitivity, signatures and overall selection intensity. However, the analysis is focused on genes that are particularly enriched in specific patients. Evaluation of the heatmap of driver mutations per patient reveals that just 38/44 (86%) of the mutations in KDM6A occur in just 4 of the 15 donors, all of women. 

```{r fig_heatmap_drivers_per_donor, fig.height = 6, fig.width = 6.5}
freq = n_ns1[rowSums(n_ns1)>=10,]
age = setNames(patientdata$age[patientdata$patient_type=="transplant"], patientdata$internal_id[patientdata$patient_type=="transplant"])[colnames(freq)]
gender = substr(setNames(patientdata$gender[patientdata$patient_type=="transplant"], patientdata$internal_id[patientdata$patient_type=="transplant"]),1,1)[colnames(freq)]
freq = freq[rev(order(rowSums(freq),decreasing = T)), order(gender,age)] # Same ordering as the driver barplot
paper_id = setNames(patientdata$paper_id[patientdata$patient_type=="transplant"], patientdata$internal_id[patientdata$patient_type=="transplant"])[colnames(freq)]

urot_ids = as.vector(lcmdata$SupplierSampleName[lcmdata$Feature=="Urothelium" & as.vector(lcmdata$Donor) %in% patientdata$external_id[patientdata$patient_type=="transplant"]])
nsamples = table(substr(unique(muts.all$sampleID[which(muts.all$sampleID %in% urot_ids)]), 1, 7)) # Number of samples sequenced per donor
nmuts = table(dndsout_ref$annotmuts$sampleID) # Number of unique mutations per donor (restricted to the targeted genes)

column_ids = colnames(freq)
colnames(freq) = paper_id[colnames(freq)]
#colnames(freq) = sapply(colnames(freq), function(x) sprintf("%s-%s%0.0f-s%0.0f:m%0.0f",x,gender[x],age[x],nsamples[x],nmuts[x])) # Adding gender and age information

grid = expand.grid(x=rownames(freq), y=colnames(freq))
grid$z = c(freq)

#dev.new(width=6.5, height=6)
library(lattice)
color.palette = colorRampPalette(c("white", "darkorange", "darkorchid2","darkorchid4","grey20"))
levelplot(z~y*x, grid, col.regions=color.palette, scales = list(tck = c(0,0), y = list(cex=1), x = list(rot=90)), ylab="Genes", xlab="Samples", colorkey=list(space="bottom"), 
panel=function(...) { arg <- list(...)
                       panel.levelplot(...)
                       panel.text(arg$x, arg$y, arg$z)})
#dev.copy(pdf, file="Driver_heatmap_bladder_finalcalls.pdf", width=6.5, height=6, useDingbats=F); dev.off(); dev.off()
```

Adding information on the number of samples and mutations per donor.

```{r fig_heatmap_drivers_per_donor, fig.height = 2.5, fig.width = 6.5}
meta = rbind(nsamples[column_ids],nmuts[column_ids])
colnames(meta) = paper_id
rownames(meta) = c("samples","mutations")
grid = expand.grid(x=rownames(meta), y=colnames(meta))
grid$z = c(meta)
#dev.new(width=6.5, height=2.5)
library(lattice)
color.palette = colorRampPalette(c("white","grey50"))
levelplot(z~y*x, grid, col.regions=color.palette, scales = list(tck = c(0,0), y = list(cex=1), x = list(rot=90)), ylab="", xlab="Samples", colorkey=list(space="bottom"), 
panel=function(...) { arg <- list(...)
                       panel.levelplot(...)
                       panel.text(arg$x, arg$y, arg$z)})
#dev.copy(pdf, file="Driver_heatmap_bladder_finalcalls_metadata.pdf", width=6.5, height=2.5, useDingbats=F); dev.off(); dev.off()
```

###Poisson regression on gender and age for the variation in dN/dS

To attempt to study differences in selection with gender, we can try using a Poisson regression model, using the counts of non-synonymous mutations in a given gene as observations and the neutral background expectation as offset, with gender as predictor and age as a possible confounding factor. 

```{r message=FALSE, warning=FALSE}
dfpats = NULL
drivers = unique(drivers, "GNA13")

# Loading RefCDS for indel model
data("refcds_hg19", package="dndscv")
RefCDS = RefCDS[sapply(RefCDS, function(x) x$gene_name) %in% targetgenes]
cds_length = setNames(sapply(RefCDS, function(x) x$CDS_length), sapply(RefCDS, function(x) x$gene_name))

for (j in 1:length(pats)) {
    
    # Calculating the neutral expectation per gene for each patient (we conservatively use kc="" to protect against lack of indels outside of driver genes)
    dnds = suppressWarnings(dndscv(mutations[mutations$sampleID==pats[j],], gene_list=targetgenes, max_muts_per_gene_per_sample = Inf, max_coding_muts_per_sample = Inf, kc=""))
    n = cbind(dnds$genemuts$n_mis, dnds$genemuts$n_non+dnds$genemuts$n_spl, dnds$genemuts$exp_mis, dnds$genemuts$exp_non+dnds$genemuts$exp_spl)
    rownames(n) = dnds$genemuts$gene_name
    if (is.null(dnds$sel_cv$n_ind)) { # Handling no indels in dndscv's indel model
        nind = expind = setNames(rep(0,nrow(n)), rownames(n))
    } else {
       nind = setNames(dnds$sel_cv$n_ind, dnds$sel_cv$gene_name)[rownames(n)]
       indelbkggenes = !(rownames(n) %in% drivers)
       expind = sum(nind[indelbkggenes])/sum(cds_length[indelbkggenes])*cds_length[rownames(n)] # indel rate per bp * gene length
    }
    n = cbind(n, nind, expind) # Adding columns for observed and expected indels per gene
    n = rbind(n, drivers=colSums(n[drivers,])) # Adding an extra entry for the sum across the genes to test
    n = n[c(drivers2test,"drivers"),]
    
    # Data frame with all the values across patients
    df = data.frame(pat=pats[j], gene=rep(rownames(n),times=3), type=rep(c("mis","tru","ind"),each=nrow(n)), obs=c(n[,1],n[,2],n[,5]), exp=c(n[,3],n[,4],n[,6]), stringsAsFactors=F)
    dfpats = rbind(dfpats, df)
}

# Adding age and gender
age = sort(setNames(patientdata$age[patientdata$patient_type=="transplant"], patientdata$internal_id[patientdata$patient_type=="transplant"]))
gender = sort(setNames(patientdata$gender[patientdata$patient_type=="transplant"], patientdata$internal_id[patientdata$patient_type=="transplant"]))
dfpats$age = age[dfpats$pat]
dfpats$gender = gender[dfpats$pat]
dfpats = dfpats[dfpats$exp>0, ] # Removing mutational categories with expected rates equal to zero

# Poisson regression for KDM6A
m_KDM6A = glm(obs ~ offset(log(exp)) + age + gender, family="poisson", data=dfpats[dfpats$gene=="KDM6A",])
summary(m_KDM6A) # Example of the Poisson regression on KDM6A

# Counter-example: Poisson regression for ARID1A (highly enriched in a single male patient)
m_ARID1A = glm(obs ~ offset(log(exp)) + age + gender, family="poisson", data=dfpats[dfpats$gene=="ARID1A",])
summary(m_ARID1A) # Example of the Poisson regression on KDM6A

# Testing all driver genes (drivers2test gene list)
genderdnds = data.frame(gene=drivers2test, pval=NA, coef=NA, stringsAsFactors=F)
for (j in 1:length(drivers2test)) {
    model = glm(obs ~ offset(log(exp)) + age + gender, family="poisson", data=dfpats[dfpats$gene==drivers2test[j],])
    genderdnds[j,2] = coef(summary(model))[3,4]
    genderdnds[j,3] = coef(summary(model))[3,1]
}
genderdnds$qval = p.adjust(genderdnds$pval, method="BH")
genderdnds = genderdnds[order(genderdnds$qval), ]
print(genderdnds)
```

The Poisson regression analysis above shows that, indeed, KDM6A shows a significant association with gender (q=0.0063), with a considerable enrichment in women. However, the test also reveals a significant enrichment of ARID1A in males (q=4.6e-8), RBM10 in males (q=4.7e-4) and KMT2D in females (q=0.011). Overall, this shows that outlier patients can dominate the Poisson regression analysis without properly evaluating whether the enrichment is unexpectedly high in a given gender. An alternative approach could be a simple permutation test, randomly permutting the gender label across patients and using a simple statistic like the ratio of dN/dS values between genders. However, this is expected to lead to largely non-significant results, since the number of possible permutations of the gender label in 15 patients is quite limited, making this test very conservative.

```{r message=FALSE, warning=FALSE}
# Calculating global obs and exp rates per gene and per patient
sums = sapply(split(dfpats, f=paste(dfpats$pat,dfpats$gene,dfpats$age,dfpats$gender)), function(x) c(sum(x$obs),sum(x$exp)))
df = as.data.frame(do.call("rbind", strsplit(colnames(sums), split=" ")))
colnames(df) = c("pat","gene","age","gender")
df$obs = sums[1,]
df$exp = sums[2,]

# Gender permutation test per gene
genderpermut = data.frame(gene=drivers2test, pval_male=NA, pval_female=NA, stringsAsFactors=F)
numsim = 1e4
for (j in 1:length(drivers2test)) {
    dfgene = df[df$gene==drivers2test[j], ]
    male = dfgene$gender=="Male"
    obs = dfgene$obs
    bkg = dfgene$exp
    genderdndsratio = function(obs, bkg, ind) { (sum(obs[ind])/sum(bkg[ind])) / (sum(obs[!ind])/sum(bkg[!ind])) }
    # Permutation test
    st = genderdndsratio(obs, bkg, male) # Observed statistic
    st_vec = sapply(1:numsim, function(x) genderdndsratio(obs, bkg, sample(male)))
    genderpermut$pval_male[j] = mean(st <= c(st,st_vec))
    genderpermut$pval_female[j] = mean(st >= c(st,st_vec))
}
print(genderpermut)
print(any(p.adjust(as.matrix(genderpermut[,2:3]), method="BH")<0.05))
```

No significant tests after FDR adjustment. This confirms the suspicion that a permutation test is quite conservative in this context, calling for caution in making statements about systematic gender differences in driver landscape based on the Poisson regression analysis. In conclusion, the size of the cohort prevents us from drawing a definitive association between the driver landscape and gender, the tests above confirm that there is extensive and highly significant variation in the driver landscape across patients. The pairwise dnds model finds significant variation for ARID1A, KMT2D, RBM10 and KDM6A. And the gender Poisson regression analysis finds significant variation for ARID1A, RBM10, KDM6A and KMT2D.

###Scatter plot of the relative frequency of drivers in normal urothelium vs TCGA

```{r fig_drivers_normalvstcga_scatterplot, fig.height = 5, fig.width = 5}
selected_genes = setdiff(union(drivers, intersect(bladder_cancer_genes,targetgenes)), "CDKN2A") # Urothelium drivers + BLCA drivers captured by TGS

# Mutation frequencies for relevant genes (absolute counts for normal urothelium and % of mutant cancers for TCGA)
freq_norm = table(dndsout_ref$annotmuts$gene[dndsout_ref$annotmuts$impact!="Synonymous"])[selected_genes]
freq_norm[is.na(freq_norm)] = 0
freq_tcga = table(unique(dndsout_blca$annotmuts[dndsout_blca$annotmuts$gene %in% selected_genes & dndsout_blca$annotmuts$impact!="Synonymous", c("sampleID","gene")])[,2])[selected_genes] / length(unique(dndsout_blca$annotmuts$sampleID)) * 100 # Percentages
freq_tcga[is.na(freq_tcga)] = 0
names(freq_norm) = names(freq_tcga) = selected_genes
selected_genes = union(names(freq_tcga[freq_tcga>0.05]), drivers) # Further restricting the plot to genes mutated in >5% TCGA tumours
freq_tcga = freq_tcga[selected_genes]
freq_norm = freq_norm[selected_genes]

# Classifying genes in 3 main pathways (based on two TCGA papers, PMID:24476821 Fig 4 and PMID:28988769 Fig3)
path1 = c("KAT2A", "KAT2B", "CREBBP", "EP300", "KMT2A", "KMT2D", "KMT2C", "KMT2B", "NSD1", "SETD2", "DOT1L", "KDM5A", "KDM1A", "KDM4A", "KDM6A", "KDM5B", "KDM1B", "KDM4B", "KDM6B", "ARID1B", "ARID1A", "SMARCC2", "SMARCC1", "SMARCA4", "SMARCA2") # Chromatin remodelling
path2 = c("FGFR3", "EGFR", "ERBB2", "ERBB3", "HRAS", "NRAS", "PIK3CA", "NF1", "PTEN", "STK11", "INPP4B", "TSC1", "TSC2", "RAC1", "FGFR1", "BRAF", "RAF1", "JAK1", "JAK2", "AKT") # RTK/Ras/PIK3K
path3 = c("ATM", "TP53", "MDM2", "CDKN2A", "CCND1", "CDKN1A", "RB1", "CCNE1", "FBXW7", "E2F3", "CDK4", "CDK6") # p53/Rb pathway

colvec = rep("grey70", length(selected_genes))
colvec[selected_genes %in% path1] = "chocolate"
colvec[selected_genes %in% path2] = "cadetblue4"
colvec[selected_genes %in% path3] = "cadetblue3"

#dev.new(height=6, width=5)
par(pty="s")
plot(as.numeric(freq_norm), as.numeric(freq_tcga), pch=16, col=colvec, las=1, ylab="% mutation in cancer (TCGA)", xlab="Number non-syn mutations normal bladder", ylim=c(0,50))
ind = freq_norm>15 | freq_tcga>10
text(x=as.numeric(freq_norm[ind]), y=as.numeric(freq_tcga[ind]), labels=selected_genes[ind], col=colvec[ind], cex=0.8)
legend(x=50, y=52, legend=c("Chromatin remodelling","RTK/Ras/PI3K pathway","p53/Rb pathway","Other"), pch=15, col=c("chocolate","cadetblue4","cadetblue3","grey70"), box.col = "white")
#dev.copy(pdf, file="Driver_scatterplot.pdf", width=5, height=6, useDingbats=F); dev.off(); dev.off(); dev.off()
```

##Figure 1 for the paper

We generate Fig 1 for the paper as two separate panels, similar to Fig 1 from Martincorena et al., 2018.

```{r fig_1_number_wxswgs_mutations, fig.height = 5, fig.width = 8}
paper_id2 = setNames(patientdata$paper_id, patientdata$internal_id)
pats = patientdata[order(patientdata$age), ]
pats = pats[order(pats$patient_type, decreasing = T), ]
age2 = setNames(pats$age, pats$internal_id)
features = as.vector(lcmdata$Feature)
features[!(features %in% c("von Brunn's nest","Urothelium","Tumour","CIS"))] = "Other"
colvec = setNames(c("grey70","cadetblue","darkorchid","darkorchid","grey70"), c("von Brunn's nest","Urothelium","Tumour","CIS","Other"))
feat = setNames(features, lcmdata$SupplierSampleName)

dev.new(width=8, height=7)
par(mfrow=c(2,1))

# WXS
m = muts.exome
f = table(m$sampleID)
nummuts = data.frame(sampleID=names(f), muts=as.numeric(f), age=age2[substr(names(f),1,7)], paper_id=paper_id2[substr(names(f),1,7)], feature=feat[names(f)])
nummuts = nummuts[order(nummuts$age, nummuts$paper_id, nummuts$muts),]
nummuts = nummuts[order(substr(nummuts$paper_id,1,1), decreasing = T), ]
nummuts$col = colvec[as.vector(nummuts$feature)]

ymax = 200
plot(pmin(ymax,nummuts$muts), pch=20, cex=0.5, las=1, col=nummuts$col, ylab="Mutations per sample", xlab="Sample number", cex.lab=0.7, cex.axis=0.7, xaxt="n", ylim=c(0,ymax), main="WXS")
start_pos = rev(rev(cumsum(rle(substr(nummuts$sampleID,1,7))$lengths)+1)[-1])-0.5 # Start position of each patient in the x-axis
abline(v=start_pos, col="grey50")
axis(1, at=c(1,seq(100,nrow(nummuts),by=100),nrow(nummuts)), las=1, cex.axis=0.7)
labelpos = (c(1,start_pos)+c(start_pos,nrow(nummuts)))/2
text(x=labelpos, y=ymax, labels=unique(as.vector(nummuts$paper_id)), cex=0.5)

# WGS
m = read.table("bld_wgs_caveman_calls.tsv", header=1, sep="\t", stringsAsFactors=F)
m_indels = read.table("bld_wgs_pindel_calls.tsv", header=1, sep="\t", stringsAsFactors=F)
    
f = table(c(m$sampleID,m_indels$sampleID)) # Substitutions and indels
nummuts = data.frame(sampleID=names(f), muts=as.numeric(f), age=age2[substr(names(f),1,7)], paper_id=paper_id2[substr(names(f),1,7)], feature=feat[names(f)])
nummuts = nummuts[order(nummuts$age, nummuts$paper_id, nummuts$muts),]
nummuts = nummuts[order(substr(nummuts$paper_id,1,1), decreasing = T), ]
nummuts$col = colvec[as.vector(nummuts$feature)]

ymax = 1e4
plot(pmin(ymax,nummuts$muts), pch=20, cex=0.8, las=1, col=nummuts$col, ylab="Mutations per sample", xlab="Sample number", cex.lab=0.7, cex.axis=0.7, xaxt="n", ylim=c(0,ymax), main="WGS")
start_pos = rev(rev(cumsum(rle(substr(nummuts$sampleID,1,7))$lengths)+1)[-1])-0.5 # Start position of each patient in the x-axis
abline(v=start_pos, col="grey50")
axis(1, at=c(1,seq(10,nrow(nummuts),by=10), nrow(nummuts)), las=1, cex.axis=0.7)
dev.copy(pdf, file="Figure_1_datasummary.pdf", width=8, height=7, useDingbats=F); dev.off(); dev.off(); dev.off()
```

Code to generate the same figure but plotting indels separately.

```{r fig_1_number_wxswgs_mutations, fig.height = 5, fig.width = 8}
paper_id2 = setNames(patientdata$paper_id, patientdata$internal_id)
pats = patientdata[order(patientdata$age), ]
pats = pats[order(pats$patient_type, decreasing = T), ]
age2 = setNames(pats$age, pats$internal_id)
features = as.vector(lcmdata$Feature)
features[!(features %in% c("von Brunn's nest","Urothelium","Tumour","CIS","Smooth Muscle"))] = "Other"
colvec = setNames(c("grey50","cadetblue","darkslateblue","darkslateblue","grey50"), c("von Brunn's nest","Urothelium","Tumour","CIS","Other"))
colvec_indels = setNames(c("grey70","lightsalmon3","lightpink4","lightpink4","grey70"), c("von Brunn's nest","Urothelium","Tumour","CIS","Other"))
feat = setNames(features, lcmdata$SupplierSampleName)

dev.new(width=8, height=7)
par(mfrow=c(2,1))

# WXS
m = muts.exome
indelrows = m$mut %in% c("-","INS") | nchar(m$ref)!=nchar(m$mut)
fsubs = table(m$sampleID[!indelrows])
finds = table(m$sampleID[indelrows])
samplenames = unique(names(fsubs),names(finds))
nummuts = data.frame(sampleID=samplenames, muts=as.numeric(fsubs[samplenames]), inds=as.numeric(finds[samplenames]), age=age2[substr(samplenames,1,7)], paper_id=paper_id2[substr(samplenames,1,7)], feature=feat[samplenames])
nummuts$muts[is.na(nummuts$muts)] = 0
nummuts$inds[is.na(nummuts$inds)] = 0

nummuts = nummuts[order(nummuts$age, nummuts$paper_id, nummuts$muts),]
nummuts = nummuts[order(substr(nummuts$paper_id,1,1), decreasing = T), ]
nummuts$col = colvec[as.vector(nummuts$feature)]
nummuts$col_indels = colvec_indels[as.vector(nummuts$feature)]
nummuts = nummuts[!(nummuts$feature=="Smooth Muscle"), ] # Excluding muscle samples

ymax = 200
plot(pmin(ymax,nummuts$muts), pch=20, cex=0.5, las=1, col=nummuts$col, ylab="Mutations per sample", xlab="Sample number", cex.lab=0.7, cex.axis=0.7, xaxt="n", ylim=c(0,ymax), main="WXS")
start_pos = rev(rev(cumsum(rle(substr(nummuts$sampleID,1,7))$lengths)+1)[-1])-0.5 # Start position of each patient in the x-axis
abline(v=start_pos, col="grey50")
axis(1, at=c(1,seq(100,nrow(nummuts),by=100),nrow(nummuts)), las=1, cex.axis=0.7)
labelpos = (c(1,start_pos)+c(start_pos,nrow(nummuts)))/2
text(x=labelpos, y=ymax, labels=unique(as.vector(nummuts$paper_id)), cex=0.5)
points(pmin(ymax,nummuts$inds), pch=20, cex=0.5, col=nummuts$col_indels)

# WGS
m_subs = read.table("bld_wgs_caveman_calls.tsv", header=1, sep="\t", stringsAsFactors=F)[,c("sampleID","CHROM","POS","REF","ALT")]
m_indels = read.table("bld_wgs_pindel_calls.tsv", header=1, sep="\t", stringsAsFactors=F)[,c("sampleID","CHROM","POS","REF","ALT")]
m = rbind(m_subs,m_indels)
    
indelrows = rep(c(0,1), times=c(nrow(m_subs),nrow(m_indels)))
fsubs = table(m$sampleID[indelrows==0])
finds = table(m$sampleID[indelrows==1])
samplenames = unique(names(fsubs),names(finds))
nummuts = data.frame(sampleID=samplenames, muts=as.numeric(fsubs[samplenames]), inds=as.numeric(finds[samplenames]), age=age2[substr(samplenames,1,7)], paper_id=paper_id2[substr(samplenames,1,7)], feature=feat[samplenames])
nummuts$muts[is.na(nummuts$muts)] = 0
nummuts$inds[is.na(nummuts$inds)] = 0

nummuts = nummuts[order(nummuts$age, nummuts$paper_id, nummuts$muts),]
nummuts = nummuts[order(substr(nummuts$paper_id,1,1), decreasing = T), ]
nummuts$col = colvec[as.vector(nummuts$feature)]
nummuts$col_indels = colvec_indels[as.vector(nummuts$feature)]
nummuts = nummuts[!(nummuts$feature=="Smooth Muscle"), ] # Excluding muscle samples

ymax = 1e4
plot(pmin(ymax,nummuts$muts), pch=20, cex=0.8, las=1, col=nummuts$col, ylab="Mutations per sample", xlab="Sample number", cex.lab=0.7, cex.axis=0.7, xaxt="n", ylim=c(1,ymax), main="WGS", log="y")
start_pos = rev(rev(cumsum(rle(substr(nummuts$sampleID,1,7))$lengths)+1)[-1])-0.5 # Start position of each patient in the x-axis
abline(v=start_pos, col="grey50")
axis(1, at=c(1,seq(10,nrow(nummuts),by=10), nrow(nummuts)), las=1, cex.axis=0.7)
points(pmin(ymax,nummuts$inds), pch=20, cex=0.5, col=nummuts$col_indels)
dev.copy(pdf, file="Figure_1_datasummary_indels_separate.pdf", width=8, height=7, useDingbats=F); dev.off(); dev.off(); dev.off()
```

